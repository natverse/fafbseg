% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cave.R
\name{flywire_cave_query}
\alias{flywire_cave_query}
\title{Query the FlyWire CAVE annotation system}
\usage{
flywire_cave_query(
  table,
  datastack_name = getOption("fafbseg.cave.datastack_name", "flywire_fafb_production"),
  version = NULL,
  timestamp = NULL,
  live = is.null(version),
  timetravel = FALSE,
  filter_in_dict = NULL,
  filter_out_dict = NULL,
  select_columns = NULL,
  offset = 0L,
  limit = NULL,
  fetch_all_rows = FALSE,
  ...
)
}
\arguments{
\item{table}{The name of the table (or view, see views section) to query}

\item{datastack_name}{defaults to "flywire_fafb_production". See
\url{https://global.daf-apis.com/info/} for other options.}

\item{version}{An optional CAVE materialisation version number. See details
and examples.}

\item{timestamp}{An optional timestamp as a string or POSIXct, interpreted as
UTC when no timezone is specified.}

\item{live}{Whether to use live query mode, which updates any root ids to
their current value (or to another \code{timestamp} when provided). Values
of \code{TRUE} or \code{1} select CAVE's \emph{Live} mode, while \code{2}
selects \code{Live live} mode which gives access even to annotations that
are not part of a materialisation version. See section \bold{Live and Live
Live queries} for details.}

\item{filter_in_dict, filter_out_dict}{Optional arguments consisting of key
value lists that restrict the returned rows (keeping only matches or
filtering out matches). Commonly used to selected rows for specific
neurons. See examples and CAVE documentation for details.}

\item{select_columns}{Either a character vector naming columns or a python
dict (required if the query involves multiple tables).}

\item{offset}{a 0-indexed row number, allows you to page through long results
(but see section \bold{CAVE Row Limits} for some caveats)}

\item{limit}{whether to limit the number of rows per query (\code{NULL}
implies no client side limit but there is typically a server side limit of
500,000 rows).}

\item{fetch_all_rows}{Whether to fetch all rows of a query that exceeds limit
(default \code{FALSE}). See section \bold{CAVE Row Limits} for some
caveats.}

\item{...}{Additional arguments to the query method. See examples and
details.}
}
\value{
A \code{tibble}. Note that xyzmatrix can be used on single columns
  containing XYZ locations.
}
\description{
Query the FlyWire CAVE annotation system
}
\details{
CAVE (Connectome Annotation Versioning Engine) provides a shared
  infrastructure for a number of connectomics projects involving Sebastian
  Seung's group at Princeton and collaborators at the Allen Institute. There
  is both a backend system running on their servers and a Python client for
  end users.

  You can find out more at \url{https://caveclient.readthedocs.io/} as well
  as looking at the Python notebooks on the github repo
  \url{https://github.com/seung-lab/CAVEclient}.

  The annotation system shares authentication infrastructure with the rest of
  the FlyWire API (see \code{\link{flywire_set_token}}).
}
\section{CAVE Materialisation Versions and Timestamps}{
 CAVE has a concept of
  table snapshots identified by an integer materialization \code{version}
  number. In some cases you may wish to query a table at this defined version
  number so that you can avoid root_ids changing during an analysis. Your
  calls will also be faster since no root id updates are required.

  Note however that materialisation versions expire at which point the
  corresponding version of the database is expunged. However it is still
  possible to find the timestamp for an expired materialisation version.
  \code{flywire_cave_query} does this automatically using
  \code{\link{flywire_timestamp}}. In these circumstances queries will again
  be slower (quite possibly slower than the live query) since all root ids
  must be recalculated to match the timestamp.

  CAVE's ability to handle different timepoints is key to analysis for a
  continually evolving segmentation but is frankly a little difficult for
  users to work with. You will find things simplest if you either \itemize{

  \item use a long-term support (LTS) version, which will not expire such as
  the 630 version for the June 2023 public release or the 783 version to
  accompany the published FlyWire papers.

  \item use the latest CAVE version

  }
}

\section{Live and Live Live queries}{
 CAVE versions the segmentation and
  annotation tables with shared version numbers. When a dataset is stable,
  using this single version works well. However, we have found that this
  arrangement is not ideal in many situations, as annotations often evolve
  even though the segmentation is static.

  CAVE has two options to update annotations to a different point in time:
  \enumerate{

  \item \bold{Live queries} take the contents of a table at some version and
  updates the root ids to match a later timepoint (usually now). However the
  set of annotations remains stuck at the selected version. The starting
  materialisation version is chosen to be the most recent one preceding the
  requested timepoint.

  \item \bold{Live live queries} (CAVE terminology, \code{live=2}) can return
  the state of an annotation table at an arbitrary timepoint. This includes
  annotations that have not yet been incorporated into a released
  materialisation version.

  }
}

\section{CAVE Views}{
 In addition to regular database tables, CAVE provides
  support for \bold{views}. These are based on a SQL query which typically
  aggregates or combines multiple tables. For an example an aggregation might
  define the total number of output synapses for some selected neurons.

  At present there are several restrictions on views. For example, you can
  only fetch views using an unexpired materialisation version (and you cannot
  specify a timepoint using a timestamp) . Furthermore some \code{filter_in,
  filter_out} queries using columns created by the SQL statement may not be
  possible.
}

\section{CAVE Row Limits}{
 CAVE servers limit the number of rows that can be
  returned for any query, typically 500,000 rows. For many queries you can
  still use increasing values of \code{offset} to page through the results.
  However, there appear to be restrictions to this. In particular for the
  synapse table, rows are returned in \emph{random} order. Therefore, even if
  you set your own row \code{limit} lower than the server's, you still cannot
  fetch all the rows of your query. Other tables (e.g. nuclei) do not have
  this limitation.
}

\examples{
\donttest{
# note use of limit to restrict the number of rows (must be integer)
n10=flywire_cave_query(table = 'nuclei_v1', limit=10L)
head(as.data.frame(n10))
}
\dontrun{
nuclei_v1=flywire_cave_query(table = 'nuclei_v1')
points3d(xyzmatrix(nuclei_v1$pt_position))

library(elmr)
# calculate signed distance to FAFB surface
# NB this surface is not a perfect fit in the optic lobes
nuclei_v1$d=pointsinside(xyzmatrix(nuclei_v1$pt_position), FAFB.surf,
  rval = 'dist')
points3d(xyzmatrix(nuclei_v1$pt_position),
  col=matlab::jet.colors(20)[cut(nuclei_v1$d,20)])
plot3d(FAFB)
}
# Example of a query on a table
\dontrun{
# the Princeton (mostly) and Cambridge groups have tagged some bodies as
# not a neuron - these are often glia.
nans=flywire_cave_query('neuron_information_v2',
  filter_in_dict = list(tag='not a neuron'))
nrow(nans)
table(nans$user_id)
}
\dontrun{
psp_351=flywire_cave_query(table = 'proofreading_status_public_v1',
  version=351)
# get the last listed materialisation version
fcc=flywire_cave_client()
lastv=tail(fcc$materialize$get_versions(), n=1)
# pull that
psp_last=flywire_cave_query(table = 'proofreading_status_public_v1',
  version=lastv)
}
}
\seealso{
\code{\link{flywire_cave_client}}

Other cave-queries: 
\code{\link{flywire_timestamp}()}
}
\concept{cave-queries}
